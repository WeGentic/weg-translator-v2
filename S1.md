# Knowledge Log (S1)

## 2025-02-14
- Confirmed SQLite `strftime` syntax for default UTC timestamps using ISO8601 (`strftime('%Y-%m-%dT%H:%M:%fZ','now')`) to ensure new migrations use canonical UTC strings [SQLite Forum](https://sqlite.org/forum/info/a149afe48016267b923a45836a984a76af084670a5545d75869ded60bd93e54d) [SQLite Date Functions Guide](https://www.sqlitetutorial.net/sqlite-date-functions/sqlite-strftime-function/).
- Reviewed best practices for storing BCP-47 language tags in SQLite, noting case normalization (lowercase language, uppercase region) and the need for application-level validation beyond simple CHECK constraints [Corner Blog](https://corner.buka.sh/understanding-bcp-47-locale-codes-the-modern-standard-for-language-and-region-tags) [W3C BCP-47 Guidance](https://www.w3.org/International/questions/qa-choosing-language-tags).
- Refreshed SQLite guidance on enumerated text CHECK constraints and aligning default values with allowed enums for integrity [SQLite Check Constraints Tutorial](https://www.sqlitetutorial.net/sqlite-check-constraint/) [SQL Easy - SQLite CHECK](https://www.sql-easy.com/learn/sqlite-check-constraints/).
- Collected best practices for modeling many-to-many relationships with junction tables, cascades, and uniqueness constraints in SQLite [Microsoft Learn](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/many-to-many) [SQLite Foreign Keys](https://sqlite.org/foreignkeys.html).
- Reviewed guidance on artifact tracking tables, covering status enums, checksum storage, and timestamp triggers for SQLite migrations [Simon Willison](https://simonwillison.net/2023/Apr/15/sqlite-history/) [SQLite Forum](https://sqlite.org/forum/info/1cb0160838780db1e216a145f285ad6dd36a0e0ede53e504f01baca963e1b99e).
- Gathered SQLite recommendations for storing JSON payloads and booleans with CHECK constraints, leveraging JSON1 tooling for validation flows [SQLite JSON1](https://sqlite.org/json1.html) [Beekeeper Studio Blog](https://www.beekeeperstudio.io/blog/sqlite-json).
- Researched job/task queue patterns in SQLite, emphasizing status enums, retry counters, and transactional reservations [Jason Gorman](https://jasongorman.uk/writing/sqlite-background-job-system/) [Shalvah Blog](https://blog.shalvah.me/posts/building-a-task-queue-part-1) [Android SQLite Performance](https://developer.android.com/topic/performance/sqlite-performance-best-practices).
- Compiled best practices for staging directories, hashing, and atomic rename flows when working with SQLite in Tauri/Rust applications [RandomEngy Tauri SQLite Guide](https://github.com/RandomEngy/tauri-sqlite) [Tauri SQLite tutorial](https://tauritutorials.com/blog/building-a-todo-app-in-tauri-with-sqlite-and-sqlx).
- Logged streaming SHA-256 hashing guidance for async staging copies using the `sha2` crate with buffered `tokio` reads, aligning with RustCrypto recommendations for large files [RustCrypto hashes](https://github.com/RustCrypto/hashes) [Thorsten Hans – Streaming SHA-256 in Rust](https://www.thorsten-hans.com/weekly-rust-trivia-compute-a-sha256-hash-of-a-file/).
- Reconfirmed Rust 1.90 filesystem recommendations for preparing staging directories, including cleaning previous attempts and relying on same-volume atomic renames via `std::fs::rename`, supported by tempfile crate guidance on cross-platform staging hygiene [Rust std::fs::rename](https://doc.rust-lang.org/std/fs/fn.rename.html) [tempfile crate](https://docs.rs/tempfile/).
- Captured SQLx guidance for safely selecting and claiming SQLite queue work (atomic `UPDATE ... RETURNING`, pooled connections, enum mapping) to avoid duplicate extraction tasks during migration [cetra3 job queue](https://cetra3.github.io/blog/implementing-a-jobq-sqlx/) [SQLx FAQ](https://github.com/launchbadge/sqlx/blob/main/FAQ.md).
- Documented rollback-safe promotion strategies for directory renames, covering same-volume atomic guarantees and staged rollback patterns recommended by current Rust filesystem guidance [Rust std::fs::rename](https://doc.rust-lang.org/std/fs/fn.rename.html) [tempfile crate docs](https://docs.rs/tempfile/).

## 2025-10-10
- Confirmed that SQLite `INSERT ... ON CONFLICT DO UPDATE` should explicitly set `updated_at` rather than relying solely on triggers, preventing recursion and ensuring consistent timestamps when upserting artifact rows [SQLite UPSERT docs](https://sqlite.org/lang_upsert.html) [SQLite Forum discussion](https://sqlite.org/forum/info/7f8a6d4c80b7ceaf).
- Reviewed audit logging patterns for JSON schema validation outcomes in SQLite, capturing validator name, status, schema context, and error payloads for traceability [Mattermost JSON audit schema](https://docs.mattermost.com/administration-guide/comply/embedded-json-audit-log-schema.html) [asg017/sqlite-jsonschema guidance](https://github.com/asg017/sqlite-jsonschema) [Simon Willison JSON audit log](https://til.simonwillison.net/sqlite/json-audit-log).

## 2025-10-11
- Cataloged approaches for mapping SQLite text enums to Rust types with SQLx, noting the need for custom `Type`/`Decode` implementations or lookup layers and highlighting the `plectrum` crate for compile-time enum integrity [Naik 2024](https://www.naiquev.in/plectrum-lookup-tables-to-rust-enums.html) [TMS Dev Blog](https://tms-dev-blog.com/rust-sqlx-basics-with-sqlite/).
- Reviewed SQLx domain module organization patterns, emphasizing entity-focused operation modules, shared pools, and transactional status transitions for multi-table workflows [TMS Dev Blog](https://tms-dev-blog.com/rust-sqlx-basics-with-sqlite/) [SQLx Discussions](https://github.com/launchbadge/sqlx/discussions/3807).
- Gathered staged import guidance: write to same-filesystem temporary dirs, validate paths, then atomically promote via `std::fs::rename` for all-or-nothing project creation in Tauri backends [Rust Atomics Thread](https://users.rust-lang.org/t/how-to-write-replace-files-atomically/42821) [Tauri Discussion](https://github.com/tauri-apps/tauri/discussions/1336).

## 2025-10-12
- Consolidated Tokio async file copy guidance: stream SHA-256 hashing using 16–64 KiB buffers, flush and `sync_all` before staging promotion, and rely on same-volume `fs::rename` for atomic moves on macOS/Windows [Tokio Tutorial](https://tokio.rs/tokio/tutorial/io) [Tokio fs docs](https://docs.rs/tokio/latest/tokio/fs/index.html) [Rust Forum](https://users.rust-lang.org/t/file-reading-async-sync-performance-differences-hyper-tokio/34696).
- Noted SQLite restriction preventing `ALTER TABLE ... ADD COLUMN` from mixing `REFERENCES` with non-NULL defaults and documented trigger/table-rebuild workarounds for enforcing NOT NULL ownership columns [SQLite ALTER TABLE](https://www.sqlite.org/lang_altertable.html) [SQLite Foreign Keys](https://www.sqlite.org/foreignkeys.html).
- Captured SQLite UPSERT/idempotency patterns: define UNIQUE keys and reuse them via `INSERT ... ON CONFLICT DO UPDATE` while referencing `excluded` values to safely update timestamps and payloads [SQLite UPSERT](https://sqlite.org/lang_upsert.html) [dnnsthnnr Blog](https://dnnsthnnr.com/blog/idempotent-database-inserts-getting-it-right).
- Logged startup inspection best practices for SQLite-backed job queues: issue read-only indexed queries for `PENDING`/`FAILED` states, log structured summaries, and avoid auto-retries until operators intervene [Jason Gorman Queue](https://jasongorman.uk/writing/sqlite-background-job-system/) [Android SQLite Performance](https://developer.android.com/topic/performance/sqlite-performance-best-practices) [SQLite Query Planner](https://www.sqlite.org/queryplanner.html).

## 2025-10-13
- Gathered SQLx migration testing practices: spin up isolated `:memory:` pools per test, run the full migrations directory, and assert schema/constraints via PRAGMA introspection for tables, foreign keys, indices, and triggers to guarantee regression coverage [Matteo Righetti — Testing SQLx](https://mattrighetti.com/2025/02/17/rust-testing-sqlx-lazy-people.html) [Exein — SQLx testing in Rust](https://www.exein.io/blog/sqlx-testing-blog-post-by-bogdan).
- Reviewed selective lint suppression guidance for Rust `dead_code` warnings, noting that integration-test-only helpers should either gain production call sites or use narrowly scoped `#[allow(dead_code)]` attributes rather than crate-wide disables [Rust by Example — unused attributes](https://doc.rust-lang.org/rust-by-example/attribute/unused.html) [Rust Users Forum — test-only dead_code discussion](https://users.rust-lang.org/t/compiler-give-warning-on-functions-used-in-test-only/15230).
- Noted that `sqlx::migrate!` paths resolve relative to the crate root (not the test file), so integration tests must reference migrations with `./migrations` when living under `src-tauri/tests/`.
